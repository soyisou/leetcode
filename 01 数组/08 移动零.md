# 题目
[283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。



**示例 1:**

``` 
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```
**示例 2:**

``` 
输入: nums = [0]
输出: [0]
```


**提示:**

``` 
1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1
```

**进阶：**
你能尽量减少完成的操作次数吗？

# 思路

> 题目中要求保序，因此使用双指针算法中的快慢指针方法即可，时间复杂度为$O(n)$。

思考：时间复杂度为何为 $O(n)$？或者有些双指针算法的写法明明为两重循环，为何时间复杂度不是 $O(n^2)$，而是 $O(n)$？如何分析呢？其实，我们不要被两重循环所迷惑，我们要思考双指针算法中的每个元素所被使用的次数。
在很多情况下，双指针算法中的每个元素最多都只被使用2次，因此时间复杂度为 $O(2 * n)$，即 $O(n)$。


# 解题方法
本题使用双指针算法即可，并且由于题目中要求新数组元素的相对顺序要和就数组元素的相对顺序保持一致，也就是说本题我们需要使用双指针算法中的快慢指针解法。

# 复杂度

时间复杂度:
> $O(n)$

空间复杂度:
> $O(1)$

# Code1

双指针算法（快慢指针，保序）

时间复杂度：$O(n)$
```Java
class Solution {
    public void moveZeroes(int[] nums) {
        int lowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.length; fastIndex ++){
            if(nums[fastIndex] != 0){
                //将非0元素移动到前面（保序移动）
                nums[lowIndex ++] = nums[fastIndex];
            }
        }
        
        //将剩余的位置全部置为0
        while(lowIndex < nums.length){
            nums[lowIndex ++] = 0;
        }
    }
}
```