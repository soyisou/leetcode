# 题目
[59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/description/)

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

**示例 1：**
``` 
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```
**示例 2：**

``` 
输入：n = 1
输出：[[1]]
```


**提示：**

1 <= n <= 20

# 思路
使用模拟思想，按照顺时针的方向，依次填入数字即可。首先依次设置好上下左右的边界，然后再根据边界依次填入即可。需要注意的是，填充的起始数据是1，终止数据是n * n.

# 解题方法
具体步骤：
1. 设置上下左右的边界，分别是t, b, l, r
2. 设置一个变量num，表示当前填充的数字
3. 当num <= n * n时，依次填充数字，填充的顺序是从左到右，从上到下，从右到左，从下到上。
4. 最后返回填充好的矩阵即可。

# Code1
时间复杂度:
> $O(n ^ 2)$  其中 n 是给定的正整数。矩阵的大小是 n×n，需要填入矩阵中的每个元素。

空间复杂度:
> $O(1)$   除了返回的矩阵以外，空间复杂度是常数。


```Java
class Solution {
    public int[][] generateMatrix(int n) {
        // 需要填充的矩阵
        int[][] mat = new int[n][n];
        //上下左右边界
        int l = 0, r = n - 1, t = 0, b = n - 1;
        //填充的数字的起始和终止
        int num = 1, tar = n * n;
        while(num <= tar){
            //从左到右
            for(int i = l; i <= r; i ++){
                mat[t][i] = num ++;
            }
            // 上边界向下移动1行
            t ++;
            
            //从上到下
            for(int i = t; i <= b; i ++){
                mat[i][r] = num ++;
            }
            // 右边界向左移动1列
            r --;
            
            //从右到左
            if (t <= b) {
                for (int i = r; i >= l; i--) {
                    mat[b][i] = num++;
                }
            }
            // 下边界向上移动1行
            b--;
            
            //从下到上
            if (l <= r) {
                for (int i = b; i >= t; i--) {
                    mat[i][l] = num++;
                }
            }
            // 左边界向右移动1列
            l++;
        }
        //返回新填充的矩阵
        return mat;
    }
}
```

注意：

原始的代码在遍历最后一行和最后一列时，没有进行边界检查，可能导致重复添加元素。通过在第三个循环和第四个循环前加入条件判断，可以确保在遍历最后一行和最后一列时仅执行一次，避免了重复添加元素的问题。
具体来说：

* 在第三个循环中，添加了一个条件判断 if (t <= b)，用于检查是否还有更多的行需要遍历。如果 t > b，说明已经遍历完所有行，就不再执行第三个循环。这样避免了在最后一行重复添加元素的问题。

* 在第四个循环中，添加了一个条件判断 if (l <= r)，用于检查是否还有更多的列需要遍历。如果 l > r，说明已经遍历完所有列，就不再执行第四个循环。这样避免了在最后一列重复添加元素的问题。

这些条件判断确保了在遍历完一行或一列后，只有在还有更多行或列需要遍历时才执行相应的循环，防止了重复添加元素，从而得到了正确的螺旋顺序遍历结果。